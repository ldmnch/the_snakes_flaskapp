{% extends "base.html" %}

{% block content %}
  <div class="game-wrapper">
    <h2><span class="emoji">üêç</span> Maze Challenge</h2>
    <p id="instructions" class="instructions">Use W, A, S and D to move through the maze. Reach the green square to win!</p>
    <p id="statusMessage" class="top-status"></p>
    <div id="canvas-container"> {# Optional container for positioning #}
        <canvas id="gameCanvas"></canvas>
    </div>
    <div class="controls">
        <button id="generate-maze-btn" class="maze-btn">Generate New Maze</button>
        <select id="mazeSizeSelect">
            <option value="3">Small (3x3)</option>
            <option value="5" selected>Medium (5x5)</option>
            <option value="7">Large (7x7)</option>
            <option value="10">Extra Large (10x10)</option>
            <option value="15">Very Large (15x15)</option>
            <option value="20">XXL (20x20)</option>
            <option value="100">HUGE!!!! (100x100)</option>
        </select>
        <button id="solve-maze-btn" class="maze-btn">Solve Maze</button>
        <button id="mute-btn" class="maze-btn">üîá Mute</button>
    </div>
  </div>

  <style>
      body {
          text-align: center;
          display: flex;
          flex-direction: column;
          align-items: center;
          min-height: 100vh;
          margin: 0;
      }

      .game-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        margin-top: 1rem;
        width: 100%;
        max-width: 1400px;
        padding: 0 1rem;
        box-sizing: border-box;
      }

      #canvas-container {
        line-height: 0;
        width: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      #gameCanvas {
          display: block;
          max-width: 95vw;
          max-height: 80vh;
          border: 2px solid white;
          background-color: white;
      }

      .controls {
          margin-top: 15px;
          display: flex; 
          flex-wrap: wrap; 
          justify-content: center;
          align-items: center; 
      }
      .maze-btn, #mazeSizeSelect { 
          padding: 0.6rem 1.2rem;
          font-weight: 600;
          border-radius: 1rem;
          border: none;
          background-color: white;
          color: black;
          cursor: pointer;
          margin: 0.5rem;
          font-family: 'Poppins', sans-serif;
          vertical-align: middle; 
      }
      .maze-btn:hover, #mazeSizeSelect:hover {
          background-color: #eee;
      }
      #statusMessage {
          font-size: 18px;
          font-weight: bold;
          margin-top: 5px;
          color: lightgreen;
          min-height: 27px;
      }
      #instructions {
          font-size: 14px;
          font-weight: normal;
          margin-top: 5px;
          color: white;
          min-height: 27px;
      }
       .emoji {
          font-size: 2rem;
          margin-right: 0.3rem;
      }
      .top-status {
        margin-bottom: 10px;
      }
  </style>

  <script>
      let trophyImg;

      // --- Audio Setup ---
      let backgroundMusic;
      let musicStarted = false; // Flag to track if music has been successfully started at least once
      let isMuted = false;
      const muteBtn = document.getElementById('mute-btn');

      function setupAudio() {
          try {
              // Create the Audio object for background music
              backgroundMusic = new Audio('/static/background_music.m4a'); // <--- YOUR MUSIC FILE PATH
              backgroundMusic.loop = true; // Make it loop
              backgroundMusic.volume = 0.3; // Set initial volume (optional, 0.0 to 1.0)

              // Attempt to play music after first interaction later
              console.log("Background music object created.");

          } catch (e) {
              console.error("Could not create audio object for background music:", e);
          }
      }
       function toggleMute() {
          if (!backgroundMusic) return; // Safety check

          isMuted = !isMuted;
          backgroundMusic.muted = isMuted;
          muteBtn.textContent = isMuted ? "üîä Unmute" : "üîá Mute";
          console.log("Music muted:", isMuted);
      }

      // Function to attempt playing music (handles browser autoplay restrictions)
      function tryStartMusic() {
          // Only try to start if it hasn't successfully started before OR if it's currently paused
          if (backgroundMusic && (!musicStarted || backgroundMusic.paused)) {
              backgroundMusic.play()
                  .then(() => {
                      console.log("Background music playing or resumed.");
                      musicStarted = true; // Music has started successfully at least once
                      // Ensure mute state is applied correctly
                      backgroundMusic.muted = isMuted;
                  })
                  .catch(error => {
                      // Autoplay was prevented OR another error occurred. User interaction is needed.
                      console.warn("Background music play failed (may need interaction):", error.message);
                      // Keep flag false if initial start failed, true if it failed on resume attempt
                      if (!musicStarted) musicStarted = false;
                  });
          } else if (backgroundMusic && !backgroundMusic.paused) {
              // If music is already playing and supposed to start, just ensure mute state is correct
              backgroundMusic.muted = isMuted;
          }
      }

      function preloadTrophyImage(){
        trophyImg = new Image();
        trophyImg.src = "/static/winnertrophy.png";
        trophyImg.onload = () => {
            console.log("Trophy image loaded!");
        };
        trophyImg.onerror = () => {
            console.error("Error loading trophy image.");
        };
      }

      // Initialize things that need the DOM to be ready
      document.addEventListener('DOMContentLoaded', (event) => {
          preloadTrophyImage();
          setupAudio(); // Prepare the audio object

          // Initial maze load
          loadMaze(parseInt(mazeSizeSelect.value || '5'));

          // Add listener for the mute button
          if (muteBtn) {
              muteBtn.addEventListener('click', toggleMute);
          }
      });


      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const newMazeBtn = document.getElementById("generate-maze-btn");
      const solveMazeBtn = document.getElementById("solve-maze-btn");
      const mazeSizeSelect = document.getElementById("mazeSizeSelect");
      const statusMessage = document.getElementById("statusMessage");
      const controlsDiv = document.querySelector('.controls');
      const titleH2 = document.querySelector('h2');

      let tileSize = 10;
      let maze = [];
      let player = { x: 1, y: 1 };
      let goal = { x: 1, y: 1 }; // Set dynamically
      let solutionPath = []; // Stores the path to solve the maze

      function drawMaze() {
          if (!maze || maze.length === 0 || !maze[0]) return;

          const vh = window.innerHeight;
          const vw = window.innerWidth;
          const controlsHeight = controlsDiv.offsetHeight || 60;
          const titleHeight = titleH2.offsetHeight || 40;
          const verticalPadding = 60;
          const horizontalPadding = 40;

          const availableHeight = vh - controlsHeight - titleHeight - verticalPadding;
          const availableWidth = Math.min(vw - horizontalPadding, 1400 - horizontalPadding);

          const tileWidthBased = Math.floor(availableWidth / maze[0].length);
          const tileHeightBased = Math.floor(availableHeight / maze.length);
          tileSize = Math.max(1, Math.min(tileWidthBased, tileHeightBased));

          canvas.width = tileSize * maze[0].length;
          canvas.height = tileSize * maze.length;

          ctx.clearRect(0, 0, canvas.width, canvas.height);

          for (let row = 0; row < maze.length; row++) {
              for (let col = 0; col < maze[row].length; col++) {
                  const drawX = col * tileSize;
                  const drawY = row * tileSize;

                  if (maze[row][col] === 1) {
                      ctx.fillStyle = "black"; // Walls
                  } else if (row === goal.y && col === goal.x) {
                      ctx.fillStyle = "green"; // Goal
                  } else {
                      ctx.fillStyle = "white"; // Open path
                  }
                  ctx.fillRect(drawX, drawY, tileSize, tileSize);
              }
          }

          // Draw solution path if it exists
          ctx.fillStyle = "blue"; // Color for solution path
          solutionPath.forEach(([y, x]) => { // Assuming path is [y, x] from backend
              ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
          });

          ctx.fillStyle = "red";
          ctx.fillRect(player.x * tileSize, player.y * tileSize, tileSize, tileSize);

          // Check if game is already won to redraw trophy after resize
          if (statusMessage.textContent.includes("üéâ")) {
                // If the trophy image exists and is loaded, draw it at the goal position
                if (trophyImg && trophyImg.complete) {
                    drawTrophy(goal.x, goal.y); // Draw at goal
                }
          }
      }


      function findStartPosition() {
          for (let y = 0; y < maze.length; y++) {
              for (let x = 0; x < maze[y].length; x++) {
                  if (maze[y][x] === 0) { return { x: x, y: y }; }
              }
          }
          return { x: 1, y: 1 }; // Fallback
      }

      function findGoalPosition() {
          if (!maze || maze.length === 0 || !maze[0]) return { x: 1, y: 1 };
          for (let y = maze.length - 1; y >= 0; y--) {
              for (let x = maze[y].length - 1; x >= 0; x--) {
                  if (maze[y][x] === 0) { return { x: x, y: y }; }
              }
          }

          const lastRow = maze.length -1;
          const lastCol = maze[0].length -1;
          // Try bottom-right corner path first
           if (maze[lastRow] && maze[lastRow][lastCol-1] === 0) return { x: lastCol-1, y: lastRow};
           if (maze[lastRow-1] && maze[lastRow-1][lastCol] === 0) return { x: lastCol, y: lastRow-1};
           // Default fallback if corners are blocked
          return { x: Math.max(1, maze[0].length - 2), y: Math.max(1, maze.length - 2) };
      }

      function loadMaze(dimension) {
          statusMessage.textContent = "Loading Maze...";

          // Attempt to start or resume music when a new maze loads
          tryStartMusic();


          fetch(`/api/generate_maze/${dimension}`)
              .then(response => {
                  if (!response.ok) throw new Error(`Network response was not ok: ${response.statusText}`);
                  return response.json();
              })
              .then(data => {
                  maze = data;
                  if (!maze || maze.length === 0 || !maze[0]) {
                      console.error("Invalid maze data received");
                      // Provide a simple default maze
                      maze = [[1,1,1,1,1],[1,0,1,0,1],[1,0,0,0,1],[1,0,1,0,1],[1,1,1,1,1]];
                   }
                  player = findStartPosition();
                  goal = findGoalPosition();
                  solutionPath = []; // Clear any previous solution
                  statusMessage.textContent = ""; // Clear loading/previous message
                  drawMaze();

                  let instructions = document.getElementById("instructions");
                  if (!instructions) { // Create new instructions if they don't exist
                      instructions = document.createElement("p");
                      instructions.id = "instructions";
                      instructions.className = "instructions";
                      instructions.textContent = "Use W, A, S and D to move through the maze. Reach the green square to win!";

                      const gameWrapper = document.querySelector(".game-wrapper");
                       // Insert before the status message for better layout
                       if (statusMessage) {
                            gameWrapper.insertBefore(instructions, statusMessage);
                       } else {
                            // Fallback if status message isn't found for some reason
                           gameWrapper.insertBefore(instructions, controlsDiv);
                       }

                  } else {
                      instructions.style.display = "block"; // Make sure it's visible if hidden before
                      instructions.textContent = "Use W, A, S and D to move through the maze. Reach the green square to win!"; // Reset text
                  }
              })
              .catch(error => {
                  console.error("Error loading maze:", error);
                  statusMessage.textContent = `Error loading maze: ${error.message}`;
                  maze = []; // Clear maze on error
                  ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
              });
      }

      function movePlayer(dx, dy) {
          if (!maze || maze.length === 0 || statusMessage.textContent.includes("üéâ")) return;

          let newX = player.x + dx;
          let newY = player.y + dy;

          // Check bounds and if the target cell is a path (0)
          if (newY >= 0 && newY < maze.length &&
              newX >= 0 && newX < maze[0].length &&
              maze[newY][newX] === 0)
          {
              player.x = newX;
              player.y = newY;
              drawMaze(); // Redraw the maze with the new player position

              if (player.x === goal.x && player.y === goal.y) {
                  statusMessage.textContent = "üéâYou reached the exit! Well done!üéâ ";
                  drawTrophy(player.x, player.y); // Displays trophy after winning.
                  removeInstructions(); // Removes instructions once player wins.

                   if (backgroundMusic && !backgroundMusic.paused) {
                       backgroundMusic.pause();
                       console.log("Background music paused on win.");
                   }


                  try {
                      // Play win sound
                      const winSound = new Audio('/static/snake_sound.m4a');
                      winSound.play().catch(error => console.error("Error playing win sound:", error));

                  } catch (e) {
                      console.error("Could not create audio object for win sound:", e);
                  }
              }
          }
      }

      function drawTrophy(x, y) {
        if (trophyImg && trophyImg.complete){
            // Ensure tileSize is valid before drawing
            if (tileSize > 0) {
                ctx.drawImage(trophyImg, x * tileSize, y * tileSize, tileSize, tileSize);
            } else {
                console.warn("Skipping trophy draw due to zero tile size.");
            }
        }
        else if (!trophyImg.complete) {
             console.warn("Trophy image not fully loaded yet, attempting redraw soon.");
             setTimeout(drawMaze, 100);
        }
        else{
            console.error("Trophy image not loaded or failed to load.");
        }
      }

      function removeInstructions(){
        const instructions = document.getElementById("instructions");
        if (instructions){
            // Instead of removing, hide it, so it can be reshown on new game
            instructions.style.display = "none";
        }
      }

      async function solveMaze() {
          if (!maze || maze.length === 0) return;

          // Try starting music on interaction (if not already started)
          tryStartMusic();

          statusMessage.textContent = "Solving...";
          solutionPath = []; // Clear previous solution path visually immediately

          try {
              const response = await fetch('/api/solve_maze', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ maze: maze, start: player, goal: goal })
              });

              if (!response.ok) {
                  // Try to parse error message from server, otherwise use status text
                  const errData = await response.json().catch(() => null);
                  const errMsg = errData?.error || response.statusText || `Server error ${response.status}`;
                  throw new Error(errMsg);
              }

              const result = await response.json();

              if (result.path && result.path.length > 0) {
                  // Backend should return list of [y, x] pairs for the path
                  solutionPath = result.path;
                  statusMessage.textContent = "‚úÖ Solution found!";
              } else {
                  statusMessage.textContent = "‚ùå No solution found or path is empty.";
                   solutionPath = []; // Ensure path is empty if API returns empty/null path
              }
          } catch (error) {
              console.error("Solve API Error:", error);
              statusMessage.textContent = `Error solving: ${error.message}`;
               solutionPath = []; // Clear path on error
          } finally {
               drawMaze(); // Redraw maze to show the solution path or clear it
          }
      }

      document.addEventListener("keydown", function (event) {
          // Try starting music on first key press (if not already started and game not won)
          if (!statusMessage.textContent.includes("üéâ")) {
               tryStartMusic();
          }

          if (statusMessage.textContent.includes("üéâ")) return; // Don't move if won

          const moves = {
            "ArrowUp": [0, -1], "w": [0, -1], "W": [0, -1],
            "ArrowDown": [0, 1], "s": [0, 1], "S": [0, 1],
            "ArrowLeft": [-1, 0], "a": [-1, 0], "A": [-1, 0],
            "ArrowRight": [1, 0], "d": [1, 0], "D": [1, 0]
          };

          if (moves[event.key]) {
              event.preventDefault(); // Prevent default browser action (e.g., scrolling)
              movePlayer(...moves[event.key]); // Call movePlayer with dx, dy
          }
           if (event.key === 'e' || event.key === 'E') { // Solve maze trigger
               event.preventDefault();
               solveMaze();
           }
      });

      newMazeBtn.addEventListener("click", function () {
          loadMaze(parseInt(mazeSizeSelect.value)); // Load maze with selected dimension
      });

      solveMazeBtn.addEventListener("click", solveMaze); // Attach solver to button click

      function debounce(func, wait) {
          let timeout;
          return function executedFunction(...args) {
              const later = () => {
                  clearTimeout(timeout);
                  func(...args);
              };
              clearTimeout(timeout);
              timeout = setTimeout(later, wait);
          };
      };

      // Debounced resize handler
      const debouncedDrawMaze = debounce(() => {
          if (maze && maze.length > 0) {
             console.log("Redrawing maze due to resize...");
             drawMaze();
          }
      }, 150); // Adjust wait time (ms) as needed

      window.addEventListener('resize', debouncedDrawMaze);

  </script>
{% endblock %}